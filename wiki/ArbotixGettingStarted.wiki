#summary Quick Introduction to the ArbotiX Package

= Introduction =
This is a quick start guide to the ArbotiX ROS drivers. It is a work in progress. Before we begin, a bit of background. This package contains an ROS node (bin/arbotix-node.py) which, combined with a custom firmware, turns the ArbotiX into a powerful hardware interface device for ROS. It allows access to digital and analog signals, servo control, and control of a differential drive or walking robot base. Because this driver can do so many different things, there are many options during setup. 

= Installing Firmware =
You'll want to update the firmware on your ArbotiX or ServoStiK. You'll need to follow the instructions found on the [http://code.google.com/p/arbotix/wiki/GettingSetup ArbotiX wiki], including installing the Arduino IDE, and robocontroller libraries. You can then copy the files found in the _firmware_ folder into your sketchbook. (In future releases, we'll have precompiled binaries of the firmware, so that you only need to install _avrdude_)

= Installing The ArbotiX Package =
You'll need to install ROS and subversion. You can then install the _vanadium_drivers_ stack, which includes the _arbotix_ package: 
{{{
mkdir vanadium-ros-pkg; cd vanadium-ros-pkg
svn checkout http://vanadium-ros-pkg.googlecode.com/svn/tags/vanadium_drivers/0.2.0 vanadium_drivers
cd vanadium_drivers; cd arbotix; make
}}}

For firmware installation see the [arbotix] documentation page. 

= Creating a YAML Specification =
The ArbotiX package is highly configurable. We suggest creating a YAML specification for your robot. 

The YAML specification should detail which servos are connected to the ArbotiX, and which controllers to load:
{{{
port: /dev/ttyUSB1
rate: 15
dynamixels: {
    head_pan: {id: 1},
    head_tilt: {id: 2, max_angle: 100, min_angle: -100}
}
}}}
In this file we have specified which port the ArbotiX should use (your port may be different, the default is /dev/ttyUSB0), the rate (in hz) that the joint_states topic should be published, and the names and IDs of our servos. The "dynamixels" parameter is a list of name: {parameters} entries for Dynamixel servos connected to our bus. An _id_ is required. Other, optional, parameters include: max_angle, min_angle both in degrees), invert (0 or 1), etc. A full list can be found on the [arbotix] documentation page.

We also want to create a launch file:
{{{
<launch>
  <node name="arbotix" pkg="arbotix" type="arbotix-node.py" output="screen">
    <rosparam file="$(find your_package)/default.yaml" command="load" />
  </node>
</launch>
}}} 

These files should be placed in an package you have created. We typically use the name robot_common, where robot would be the name of your robot, for instance, nelson_common.

= Testing it Out: Blink the LED =
We can test that things are working by starting a _roscore_, our _arbotix_ node (using the launch file created earlier), and then calling the setDigital service to turn on an  LED (we'll use digital pin 1).
{{{
rosservice call /setDigital 1 1 1
}}}
The first parameter (1) is the pin number, the second is >0 for output, and the last is that we want the pin set to high for on. We can turn the LED off with:
{{{
rosservice call /setDigital 1 1 0
}}}
Which leaves the pin configured as an output, but pulls it back low. 

= Testing it Out: Controller GUI =
In our example YAML and launch files, we gave our robot a pan and tilt head, with servos called head_pan and head_tilt. We can now control them using the Controller GUI:
{{{
rosrun arbotix controllerGUI.py
}}}
You should be able to move around the head pan/tilt sliders and see the head move. 

= Controllers =
We mentioned before that the node just publishes the "joint_state" updates and handles the digital/analog services -- how then is our head moving? The core also starts controllers that we define. In our YAML file, we did not define any controllers -- so the ArbotiX node created a default controller for us. This default controller is simply a joint_controller, which is controlling all servos. It is sent information over the cmd_joints topic (msg type sensor_msgs/JointState). The code of the controllerGUI is an example example of how to control servos easily in your own program.

You can launch other controllers using your YAML file, here's a more sophisticated one that starts a base_controller, joint_controller, and a PML sensor:
{{{
port: /dev/ttyUSB1
rate: 15
sensors: {
    "pml": {type: pml}
}
controllers: {
    "j_con": {type:joint_controller,joints:["head_pan","head_tilt"]},
    "b_con": {type:base_controller,base_width:0.145,ticks_meter:26145}
}
dynamixels: {
    head_pan: {id: 1, invert: 1},
    head_tilt: {id: 2, max_angle: 100, min_angle: -100}
}
}}}